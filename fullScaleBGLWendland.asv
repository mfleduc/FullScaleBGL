%% Full scale basis graphical lasso
function fullScaleBGLWendland(lambdas,lvls)
% clear variables; close all;
fprintf('Running Full-Scale Basis Graphical Lasso with %d levels of resolution and lambdas %.4f to %.4f\n'...
    ,lvls,lambdas(1),lambdas(end))
fprintf('Wendland covariance model\n');
nneeds = [12,60,252,1020]+1;
rng(6516156)
cd('/glade/work/mleduc/GP emulation/needlet fbgl');
addpath( genpath('/glade/work/mleduc/Ionosphere_inversion/NeedMat/') );
addpath( genpath('/glade/work/mleduc/Ionosphere_inversion/Spherical-Harmonic-Transform/') );
addpath( genpath('/glade/work/mleduc/Ionosphere_inversion/spherepts/') );
addpath( genpath('/glade/work/mleduc/BigQUIC_release/'))
addpath( genpath('/glade/work/mleduc/MultivariateBasisGraphicalLasso'))
addpath( genpath('/glade/work/mleduc/FMGL-0/'))
addpath( genpath('/glade/work/mleduc/GP emulation/needlet fbgl/NeedletBGL'));
addpath( genpath('/glade/work/mleduc/S2-Sampling-Toolbox'));

load(sprintf('needlets degree resolution j=5.mat'), 'A');
A = [ones(size(A,1),1)/2/sqrt(pi),A];
load('mean of beta algorithm residual transform alt final.mat' ,'coeffs', ...
    'a00','c00', 'testdata','finalfit','LAT', 'LON' );
% lambdas = [1,0.5,0.25,0.1,0.05,0.03,0.025];
%% Split into time steps
timendx = 1;
testdata = reshape(testdata, [],25,6); 
data = testdata - mean(testdata, 2);
data = data(:,:,timendx)./std(data(:,:,timendx),[],2);
%% 
optparams = struct; 
optparams.algorithm='simanneal';
optparams.ranges = [[-10,1];%log10(tau^2)
                    [1, 20];%theta1
                    [0.01,3]];%alpha2
% optparams.ranges = [-10,1];
optparams.maxiters = 500; %number of simulated annealing steps
optparams.npts = 501; %Number of lattice points
optparams.x0 = [-4,10,0.5];%Initial guess
optparams.pchange = 0.9;
% A = [ones(64800,1)/2/sqrt(pi), A]; 
for lambda = lambdas %% cross-validate for each lambda
    ncvs = 5;
    nptseach = 8000;
    ndcs = randperm(size(A,1));
    Qest = cell(ncvs,1);
    np = [];
    %% We want to fit a Wendland covariance
    for nn = 1:ncvs
        
        thesendcs = ndcs((nn-1)*nptseach+1:nn*nptseach);
        Ahat = A(thesendcs,1:nneeds(lvls));
        thisdata = data(thesendcs,:);
        % [alpha,tausq] = FitNugget(Ahat, thisdata );

       
        
        LATd=LAT(thesendcs);LONd=LON(thesendcs);
        % d = zeros(nptseach);
        % for ii = 1:nptseach
        %     d(ii:end,ii) = distance([LATd((ii)),LONd((ii))],...
        %     [LATd(ii:end), LONd(ii:end)]);
        % end
        [spx,spy,spz] = sph2cart(pi/180*LONd, pi/180*LATd,1);
        spc=[spx,spy,spz];
        d = real(acosd(spc*spc') );% d = d -diag(diag(d));
        % d = d+d';
        covmodel = @(x)WendlandCov(x,d,'cov');
        fnname = func2str(covmodel);
        fnname = fnname(5:end);
        ndx = strfind(fnname, '('); 
        fnname = fnname(1:ndx-1);
        fprintf('********************lambda = %.4f, Training Set %d **********************\n',lambda,nn);
        fprintf('Fitting inital guess...')
        fn = @(x)NoiseObjectiveFirst( x, covmodel, Ahat,thisdata );
        paramranges = [[0:1/500:1;
            linspace(-10,0,501);
            linspace()]
        [val,obj,paramvec] = SimulatedAnnealing(fn, [[0,1];[optparams.ranges]], 200,0.9,1e-3,[250,250,250,250]);
        fprintf('Done\n');
        optparams.x0 = paramvec(2:end);
        [Qest{nn}, np(nn,:)] = CalculateQAndSigma(thisdata, Ahat, lambda, ...
            1e-2,covmodel,optparams, strcmpi(fnname,'MarkovRandomField') );
    end
    
    save(sprintf('FSBGL Nugget first/FSBGL results %d levels time %d lambda %.4f covmodel %s nugg first.mat',lvls,timendx,lambda , fnname),'tausq', 'Qest', 'np', 'optparams', 'timendx','covmodel','lambda','ndcs','nptseach','-v7.3')
end

end

